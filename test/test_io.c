#include <check.h>
#include <regex.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "dalloc_io.h"
#include "test_io.h"

#define OUT_LOG_FILE_NAME "dalloc_test_io.log"
#define ERR_LOG_FILE_NAME "dalloc_test_io.err"

FILE *stdout_log;
FILE *stderr_log;

const char *messages[6] = { ""
	, "ERROR"
	, "WARNING"
	, "INFO"
	, "DIAGNOSTIC"
	, "DEBUG"
};

void io_tests_setup() {
	stdout_log = freopen(OUT_LOG_FILE_NAME, "w", stdout);
	stderr_log = freopen(ERR_LOG_FILE_NAME, "w", stderr);

	// Default logging behaviour for these tests is to log everything.
	// Any test which relies on different behaviour will need to
	// manually configure the log level.
	set_log_level(DALLOC_LOG_LEVEL_DEBUG);
}

void io_tests_teardown() {
	uint32_t num_results = 4;
	uint32_t results[num_results];

	results[0] = fclose(stdout_log);
	stdout_log = NULL;
	results[1] = remove(OUT_LOG_FILE_NAME);

	results[2] = fclose(stderr_log);
	stderr_log = NULL;
	results[3] = remove(ERR_LOG_FILE_NAME);

	for (uint32_t i = 0; i < num_results; i++) {
		ck_assert_int_eq(0, results[i]);
	}
}

/*
Read entire contents of file into a null-terminated string. File must
not be open when this is called. The string is owned by the caller.
*/
char *read_to_end(const char *file_name) {
	FILE *file = fopen(file_name, "r");

	// Get file length.
	fseek(file, 0, SEEK_END);
	int32_t file_length = ftell(file);

	// Allocate a buffer to hold file contents. This would be
	// problematic for large files.
	char *buf = malloc(file_length + 1);
	buf[file_length] = 0;

	// Move back to start of file.
	fseek(file, 0, SEEK_SET);

	// Read contents of file. todo: read in chunks?
	int32_t res = fread(buf, 1, file_length, file);
	ck_assert_int_eq(file_length, res);

	fclose(file);

	return buf;
}

/*
Return null-terminated stdout generated by the test up to this point.
The result is owned, and must be freed by, the caller.
*/
char *get_test_stdout() {
	fclose(stdout_log);
	char *result = read_to_end(OUT_LOG_FILE_NAME);
	stdout_log = freopen(OUT_LOG_FILE_NAME, "w", stdout);
	return result;
}

/*
Return null-terminated stderr generated by the test up to this point.
The result is owned, and must be freed by, the caller.
*/
char *get_test_stderr() {
	fclose(stderr_log);
	char *result = read_to_end(ERR_LOG_FILE_NAME);
	stderr_log = freopen(ERR_LOG_FILE_NAME, "w", stderr);
	return result;
}

void assert_regex_match(const char *str, const char *pattern) {
	regex_t regex;

	// Compile the regular expression.
	int32_t res = regcomp(&regex, pattern, REG_NOSUB | REG_EXTENDED);

	ck_assert_int_eq(0, res);

	// Execute the regular expression.
	regmatch_t match;
	res = regexec(&regex, str, 1, &match, 0);
	ck_assert_int_eq(0, res);
	regfree(&regex);
}

START_TEST(test_log) {
	// Write a message with the specified log level.
	char *msg = "short error message";
	log_message(_i, msg);

	// Read stdout/stderr.
	char *output = get_test_stdout();
	char *error = get_test_stderr();

	// Errors should be written to stderr.
	// Everything else should go to stdout.
	char *written = NULL;
	if (_i == DALLOC_LOG_LEVEL_ERROR) {
		ck_assert_int_eq(0, strlen(output));
		ck_assert_int_ne(0, strlen(error));
		written = error;
	} else {
		ck_assert_int_ne(0, strlen(output));
		ck_assert_int_eq(0, strlen(error));
		written = output;
	}

	// Use a regex to ensure the output looks as expected.
	const char *msgType = messages[_i];
	char *fmt = "dalloc .+ %s: %s\n";
	char pattern[strlen(fmt) + strlen(msgType) + strlen(msg) - 3];
	sprintf(pattern, fmt, msgType, msg);
	assert_regex_match(written, pattern);

	free(output);
	free(error);
}
END_TEST

START_TEST(ensure_log_verbosity_is_respected) {
	const char *msg = "This is a log message.";

	int log_level = _i / 5;
	int message_verbosity = _i % 5 + 1;

	set_log_level(log_level);
	log_message(message_verbosity, msg);

	char *output = get_test_stdout();
	char *error = get_test_stderr();

	int outlen = strlen(output);
	int errlen = strlen(error);

	free(output);
	free(error);

	int writtenLen = message_verbosity == DALLOC_LOG_LEVEL_ERROR
		? errlen
		: outlen;
	int notWrittenLen = message_verbosity == DALLOC_LOG_LEVEL_ERROR
		? outlen
		: errlen;

	// E.g. Write warning vs only logging errors
	if (message_verbosity > log_level) {
		// Message was not written.
		ck_assert_int_eq(0, outlen);
		ck_assert_int_eq(0, errlen);
	} else {
		ck_assert_int_ne(0, writtenLen);
		ck_assert_int_eq(0, notWrittenLen);
	}
}
END_TEST

Suite *d_io_test_suite() {
	Suite* suite;
    TCase* test_case;

    suite = suite_create("io tests");
    test_case = tcase_create("d_io test case");
	tcase_add_checked_fixture(test_case, io_tests_setup, io_tests_teardown);
    suite_add_tcase(suite, test_case);

	tcase_add_loop_test(test_case, test_log, 1, 6);
	tcase_add_loop_test(test_case, ensure_log_verbosity_is_respected, 0, 30);

	return suite;
}
