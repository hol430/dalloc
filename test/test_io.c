#include <stdbool.h>
#include <check.h>
#include <regex.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "dalloc_io.h"
#include "dalloc_io_internal.h"
#include "test_io.h"
#include "test_util.h"

#define OUT_LOG_FILE_NAME "dalloc_test_io.log"
#define ERR_LOG_FILE_NAME "dalloc_test_io.err"

FILE *stdout_log;
FILE *stderr_log;

bool robust;
bool sigill_raised = false;

bool robust_mode() {
	return robust;
}

#define NUM_MSG_TYPES 7
const char *messages[NUM_MSG_TYPES] = { ""
	, "ERROR"
	, "WARNING"
	, "INFO"
	, "DIAGNOSTIC"
	, "DEBUG"
	, "UNKNOWN"
};

void io_tests_setup() {
	stdout_log = freopen(OUT_LOG_FILE_NAME, "w", stdout);
	stderr_log = freopen(ERR_LOG_FILE_NAME, "w", stderr);

	// Default logging behaviour for these tests is to log everything.
	// Any test which relies on different behaviour will need to
	// manually configure the log level.
	set_log_level(DALLOC_LOG_LEVEL_DEBUG);
	robust = true;
	sigill_raised = false;
}

void io_tests_teardown() {
	uint32_t num_results = 4;
	uint32_t results[num_results];

	results[0] = fclose(stdout_log);
	stdout_log = NULL;
	results[1] = remove(OUT_LOG_FILE_NAME);

	results[2] = fclose(stderr_log);
	stderr_log = NULL;
	results[3] = remove(ERR_LOG_FILE_NAME);

	for (uint32_t i = 0; i < num_results; i++) {
		ck_assert_int_eq(0, results[i]);
	}
}

/*
Read entire contents of file into a null-terminated string. File must
not be open when this is called. The string is owned by the caller.
*/
char *read_to_end(const char *file_name) {
	FILE *file = fopen(file_name, "r");

	// Get file length.
	fseek(file, 0, SEEK_END);
	int32_t file_length = ftell(file);

	// Allocate a buffer to hold file contents. This would be
	// problematic for large files.
	char *buf = malloc(file_length + 1);
	buf[file_length] = 0;

	// Move back to start of file.
	fseek(file, 0, SEEK_SET);

	// Read contents of file. todo: read in chunks?
	int32_t res = fread(buf, 1, file_length, file);
	ck_assert_int_eq(file_length, res);

	fclose(file);

	return buf;
}

/*
Return null-terminated stdout generated by the test up to this point.
The result is owned, and must be freed by, the caller.
*/
char *get_test_stdout() {
	fclose(stdout_log);
	char *result = read_to_end(OUT_LOG_FILE_NAME);
	stdout_log = freopen(OUT_LOG_FILE_NAME, "w", stdout);
	return result;
}

/*
Return null-terminated stderr generated by the test up to this point.
The result is owned, and must be freed by, the caller.
*/
char *get_test_stderr() {
	fclose(stderr_log);
	char *result = read_to_end(ERR_LOG_FILE_NAME);
	stderr_log = freopen(ERR_LOG_FILE_NAME, "w", stderr);
	return result;
}

void assert_regex_match(const char *str, const char *pattern) {
	regex_t regex;

	// Compile the regular expression.
	int32_t res = regcomp(&regex, pattern, REG_NOSUB | REG_EXTENDED);

	ck_assert_int_eq(0, res);

	// Execute the regular expression.
	regmatch_t match;
	res = regexec(&regex, str, 1, &match, 0);
	ck_assert_int_eq(0, res);
	regfree(&regex);
}

void validate_log_message(const char *msg, int log_level) {
	ck_assert_int_lt(log_level, NUM_MSG_TYPES);

	// Read stdout/stderr.
	char *output = get_test_stdout();
	char *error = get_test_stderr();

	// Errors should be written to stderr.
	// Everything else should go to stdout.
	char *written = NULL;
	if (log_level == DALLOC_LOG_LEVEL_ERROR) {
		// stdout should be empty, stderr should be nonempty.
		ck_assert_int_eq(0, strlen(output));
		ck_assert_int_ne(0, strlen(error));
		written = error;
	} else {
		// stdout should be nonempty, stderr should be empty.
		ck_assert_int_ne(0, strlen(output));
		ck_assert_int_eq(0, strlen(error));
		written = output;
	}

	// Use a regex to ensure the output looks as expected.
	const char *msgType = messages[log_level];
	char *fmt = "dalloc .+ %s: %s\n";
	char pattern[strlen(fmt) + strlen(msgType) + strlen(msg) - 3];
	sprintf(pattern, fmt, msgType, msg);
	assert_regex_match(written, pattern);

	free(output);
	free(error);
}

START_TEST(test_log) {
	// Write a message with the specified log level.
	char *msg = "short error message";
	set_log_level(_i);
	log_message(_i, msg);

	validate_log_message(msg, _i);
}
END_TEST

START_TEST(test_log_explicit) {
	const char *msg = "hello";
	if (_i == 1) {
		log_error(msg);
	} else if (_i == 2) {
		log_warning(msg);
	} else if (_i == 3) {
		log_info(msg);
	} else if (_i == 4) {
		log_diag(msg);
	} else if (_i == 5) {
		log_debug(msg);
	} else {
		set_log_level(_i);
		log_message(_i, msg);
	}
	validate_log_message(msg, _i);
}
END_TEST

START_TEST(ensure_log_verbosity_is_respected) {
	const char *msg = "This is a log message.";

	int log_level = _i / 5;
	int message_verbosity = _i % 5 + 1;

	set_log_level(log_level);
	log_message(message_verbosity, msg);

	char *output = get_test_stdout();
	char *error = get_test_stderr();

	int outlen = strlen(output);
	int errlen = strlen(error);

	free(output);
	free(error);

	int writtenLen = message_verbosity == DALLOC_LOG_LEVEL_ERROR
		? errlen
		: outlen;
	int notWrittenLen = message_verbosity == DALLOC_LOG_LEVEL_ERROR
		? outlen
		: errlen;

	// E.g. Write warning vs only logging errors
	if (message_verbosity > log_level) {
		// Message was not written.
		ck_assert_int_eq(0, outlen);
		ck_assert_int_eq(0, errlen);
	} else {
		ck_assert_int_ne(0, writtenLen);
		ck_assert_int_eq(0, notWrittenLen);
	}
}
END_TEST

START_TEST(test_pad) {
	uint32_t value = 34;
	uint16_t num_digits = 5;
	char *buf = malloc(sizeof(char) * (num_digits + 1));
	buf[num_digits] = 0; // NULL terminator
	int res = pad(value, num_digits, buf);
	ck_assert_uint_eq(0, res);
	ck_assert_str_eq("00034", buf);
	free(buf);
}
END_TEST

START_TEST(test_pad_large_number) {
	// Attempt to pad out to N digits a number with >N digits.
	uint32_t value = 1234;
	char buf[7];
	for (uint16_t num_digits = 0; num_digits < 4; num_digits++) {
		uint32_t res = pad(value, num_digits, buf);
		ck_assert_uint_eq(1, res);
	}
	buf[4] = 0;
	uint32_t res = pad(value, 4, buf);
	ck_assert_uint_eq(0, res);
	ck_assert_str_eq("1234", buf);
	buf[5] = 0;
	res = pad(value, 5, buf);
	ck_assert_uint_eq(0, res);
	ck_assert_str_eq("01234", buf);
}
END_TEST

void sigill_handler(int32_t signum) {
	// Verify that the correct signal was raised.
    ck_assert_int_eq(SIGILL, signum);
	sigill_raised = true;
}

START_TEST(test_panic) {
	const char *msg = "error message";
	// Attach a custom handler for SIGILL, which will assert that the raised
	// signal is SIGILL, and also set sigill_raised to true.
	attach_signal_handler(SIGILL, sigill_handler);
	ck_assert_int_eq(false, sigill_raised);

	// We've mocked the robust_mode() function such that it relies on this var.
	robust = true;

	// Call panic() - this should not trigger a crash.
	panic(msg);
	ck_assert_int_eq(false, sigill_raised);

	// Ensure that a log message was written though.
	validate_log_message(msg, DALLOC_LOG_LEVEL_ERROR);

	// Now set robust to false, and call panic(). This should raise SIGILL.
	robust = false;
	panic(msg);
	ck_assert_int_eq(true, sigill_raised);

	// Detach the signal handler.
	detach_signal_handlers(SIGILL);
}
END_TEST

Suite *d_io_test_suite() {
	Suite* suite;
    TCase* test_case;

    suite = suite_create("io tests");
    test_case = tcase_create("d_io test case");
	tcase_add_checked_fixture(test_case, io_tests_setup, io_tests_teardown);
    suite_add_tcase(suite, test_case);

	tcase_add_loop_test(test_case, test_log, 1, 7);
	tcase_add_loop_test(test_case, test_log_explicit, 1, 7);
	tcase_add_loop_test(test_case, ensure_log_verbosity_is_respected, 0, 30);
	tcase_add_test(test_case, test_pad);
	tcase_add_test(test_case, test_panic);
	tcase_add_test(test_case, test_pad_large_number);

	return suite;
}
